/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"

#define FLASH_ID_HOUR	1
#define FLASH_ID_MINUTE	2
#define FLASH_ID_RED	3
#define FLASH_ID_GREEN	4
#define FLASH_ID_BLUE	5
#define FLASH_ID_ROOM	6



uint8_t sceneNumber = 0, currentSceneNumber = 0;

appState_t deviceState = STARTUP;
ucg_t ucg;

uint8_t buttonTimerSubmitEventControl = 0;
int8_t VerticalValue = 0, HorizontalValue = 0;

int16_t userChoiceXY[2] = {0,0};
Choice_t currentChoice = Screen0_None, lastChoice = Screen0_None;

Choice_t screen1List[8] = {	Screen1_Setting, Screen1_Manual,Screen1_Auto, Screen1_Storm,
							Screen1_Fire, Screen1_Aurora, Screen1_Party, Screen1_Off
							};
Choice_t screen2List[3] = {Screen2_Red, Screen2_Green, Screen2_Blue};
Choice_t screen3List[2] = {Screen3_Room, Screen3_Time};
Choice_t screen4List[5] = {Screen4_Living,Screen4_Sleep,Screen4_Study,Screen4_Dining,Screen4_Excercise};
Choice_t screen5List[2] = {Screen5_Hour, Screen5_Minute};

int16_t color[3];
char red[20], blue[20], green[20];
int16_t time[3];
char hour[20], minute[20], currentTime[40];
uint8_t room;
char currentRoom[20];
SSwTimer changeSceneTimer = NO_TIMER;
SSwTimer ButtonHoldTimer = NO_TIMER;
SSwTimer SendDataTimer = NO_TIMER;

messageFrame_t messageFrame = {0xB1,0,0,0xFF};
uint32_t delayNeeded = 100;

ButtonState_t ButtonState;

uint8_t inbuf[20];
uint32_t bufpos;

void RetrieveDataFromFlash();
void UpdateDataToFlash();

int main(void)
{
	SystemCoreClockUpdate();
	AppInitCommon();
	flashConfig();
	RetrieveDataFromFlash();
	TimeBasic_Init();
	ConfigUSARTBuffer(Room, room);
	USART2_SendMessage();
    /* Loop forever */
	while(1){
		processTimerScheduler();
		appStateManager();
	}
}


void TimeBasic_Init(){
	TIM_TimeBaseInitTypeDef Timer_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

	Timer_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	Timer_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	Timer_InitStructure.TIM_Period = 999999;
	Timer_InitStructure.TIM_Prescaler = 83; //1MHz
	Timer_InitStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM2, &Timer_InitStructure);
	TIM_Cmd(TIM2, ENABLE);

	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

	NVIC_Init(&NVIC_InitStructure);
}

void TIM2_IRQHandler(void){
	time[2]++;
	if (time[2] >= 60){
		time[2] = 0;
		time[1]++;
		UpdateDataToFlash();
		if((sceneNumber == 0) && (currentChoice == Screen0_None)){
			LoadConfiguration();
		}
	}if(time[1] >= 60){
		time[1] = 0;
		time[1]++;

		ConfigUSARTBuffer(Hour, time[0]);
		USART2_SendMessage();
	}if(time[0] >= 24){
		time[0] = 0;
	}
	TIM_SetCounter(TIM2, 0);
	TIM_ClearFlag(TIM2, TIM_IT_Update);
}

void RetrieveDataFromFlash(){
	color[0] = (int16_t)flashReadWord(FLASH_ID_RED);
	color[1] = (int16_t)flashReadWord(FLASH_ID_GREEN);
	color[2] = (int16_t)flashReadWord(FLASH_ID_BLUE);

	time[0] = (int16_t)flashReadWord(FLASH_ID_HOUR);
	time[1] = (int16_t)flashReadWord(FLASH_ID_MINUTE);
	room = (uint8_t)flashReadWord(FLASH_ID_ROOM);
}


void UpdateDataToFlash(){
	FLASH_Status stat;
	while (flashClear() != FLASH_COMPLETE);
	stat= flashWrite(FLASH_ID_RED, (uint32_t)color[0]);
	stat=flashWrite(FLASH_ID_GREEN,(uint32_t)color[1]);
	stat=flashWrite(FLASH_ID_BLUE, (uint32_t)color[2]);

	stat=flashWrite(FLASH_ID_HOUR, (uint32_t)time[0]);
	stat=flashWrite(FLASH_ID_MINUTE, (uint32_t)time[1]);
	stat=flashWrite(FLASH_ID_ROOM, (uint32_t)room);
}


void AppInitCommon(){
	TimerInit();
	Ucglib4WireSWSPI_begin(&ucg, UCG_FONT_MODE_SOLID);
	ucg_SetFont(&ucg ,ucg_font_ncenB10_hr);
	ucg_SetColor(&ucg, 0, 255, 255, 255); // Trang
	ucg_SetRotate180(&ucg);
	USART2_Init();
	ButtonInit();
}

void appStateManager(){
	switch(deviceState){
	case STARTUP:
		LoadConfiguration();
		deviceState = MAIN;
		break;
	case MAIN:
		MAIN_RefreshChoices();
		break;
	default:
		break;
	}
}

void MAIN_RefreshChoices(){
	//wait till all button is release
	switch(ButtonState){
	case ButtonReleased:
		VerticalValue = 0;
		HorizontalValue = 0;
		if(ALL_BUTTON_NOT_RELEASED){
			ButtonState = ButtonPressed;
		}
		break;
	case ButtonPressed:
		 HorizontalValue= - (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID2) + (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID4);
		 VerticalValue=  (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID5) - (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID1);
		ProcessDirection();
		TimerStop(ButtonHoldTimer);
		ButtonHoldTimer = TimerStart("ProcessDir",500, TIMER_REPEAT_FOREVER, ProcessDirection, 0);
		ButtonState = ButtonHolding;
		break;
	case ButtonHolding:
		if(ALL_BUTTON_RELEASED){
			ButtonState = ButtonSubmitted;
			TimerStop(ButtonHoldTimer);
			ButtonHoldTimer = NO_TIMER;
		}else{
			HorizontalValue= - (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID2) + (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID4);
			VerticalValue = (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID5) - (int8_t)!Button_GetLogicInputPin(BUTTON_KIT_ID1);
		}
		break;
	case ButtonSubmitted:
		ButtonState = ButtonReleased;
		TimerStop(SendDataTimer);
		SendDataTimer = TimerStart("SendData",1000, TIMER_REPEAT_ONE_TIME, USART2_SendMessage, 0);
		break;
	}
}

void SubmitButtonHandler(){
	UpdateDataToFlash();
	if (sceneNumber == 0){
		sceneNumber = 1;
		currentChoice = Screen1_Setting;
	}
	else if(sceneNumber == 1){
		if (currentChoice == Screen1_Manual){
			sceneNumber = 2;
			currentChoice = Screen2_Red;
		}else if (currentChoice == Screen1_Setting){
			sceneNumber = 3;
			currentChoice = Screen3_Room;
		}else{
			sceneNumber = 6;
			currentChoice = Screen6_End;
		}
		userChoiceXY[0] = 0;
		userChoiceXY[1] = 0;
	}else if (sceneNumber == 2){
		sceneNumber = 6;
		currentChoice = Screen6_End;
		userChoiceXY[0] = 0;
	}else if (sceneNumber == 3){
		if (currentChoice == Screen3_Room){
			sceneNumber = 4;
			currentChoice = Screen4_Living;
		}else if (currentChoice == Screen3_Time){
			sceneNumber = 5;
			currentChoice = Screen5_Hour;
		}
		userChoiceXY[0] = 0;
		userChoiceXY[1] = 0;
	}else if (sceneNumber == 4){
		sceneNumber = 6;
		currentChoice = Screen6_End;
		userChoiceXY[0] = 0;
		userChoiceXY[1] = 0;
	}else if (sceneNumber == 5){
		sceneNumber = 6;
		currentChoice = Screen6_End;
		userChoiceXY[0] = 0;
	}else if (sceneNumber == 6){
		sceneNumber = 0;
		currentChoice = Screen0_None;
		userChoiceXY[0] = 0;
	}
	screenRefresh();
}

void ProcessDirection(){
	if(sceneNumber == 1){
		if(VerticalValue || HorizontalValue){
			userChoiceXY[0] += VerticalValue;
			if(userChoiceXY[0] < 0){
				userChoiceXY[0] = 7;
			}else if(userChoiceXY[0] > 7){
				userChoiceXY[0] = 0;
			}
			currentChoice = screen1List[userChoiceXY[0]];
		}
	}else if (sceneNumber == 2){
		if(VerticalValue || HorizontalValue){
			userChoiceXY[0] += VerticalValue;
			if(userChoiceXY[0] < 0){
				userChoiceXY[0] += 1;
			}else if(userChoiceXY[0] > 2){
				userChoiceXY[0] -= 1;
			}
			currentChoice = screen2List[userChoiceXY[0]];
			color[userChoiceXY[0]] += 5*HorizontalValue;

			if(color[userChoiceXY[0]] < 0){
				color[userChoiceXY[0]] = 255;
			}else if(color[userChoiceXY[0]] > 255){
				color[userChoiceXY[0]] = 0;
			}
		}
	}else if (sceneNumber == 3){
		if(VerticalValue || HorizontalValue){
			userChoiceXY[0] += VerticalValue;


			if(userChoiceXY[0] < 0){
				userChoiceXY[0] = 1;
			}else if(userChoiceXY[0] > 1){
				userChoiceXY[0] = 0;
			}
			currentChoice = screen3List[userChoiceXY[0]];
		}
	}else if (sceneNumber == 4){
		if(VerticalValue || HorizontalValue){
			userChoiceXY[0] += VerticalValue;


			if(userChoiceXY[0] < 0){
				userChoiceXY[0] = 4;
			}else if(userChoiceXY[0] > 4){
				userChoiceXY[0] = 0;
			}
			currentChoice = screen4List[userChoiceXY[0]];
		}
	}else if (sceneNumber == 5){
		if(VerticalValue || HorizontalValue){
			userChoiceXY[0] += VerticalValue;


			if(userChoiceXY[0] < 0){
				userChoiceXY[0] += 1;
			}else if(userChoiceXY[0] > 1){
				userChoiceXY[0] -= 1;
			}
			currentChoice = screen5List[userChoiceXY[0]];
			time[userChoiceXY[0]] += HorizontalValue;
			if (currentChoice == Screen5_Hour){
				if(time[userChoiceXY[0]] < 0){
					time[userChoiceXY[0]] = 23;
				}else if(time[userChoiceXY[0]] > 23){
					time[userChoiceXY[0]] = 0;
				}
			}else if (currentChoice == Screen5_Minute){
				if(time[userChoiceXY[0]] < 0){
					time[userChoiceXY[0]] = 59;
				}else if(time[userChoiceXY[0]] > 59){
					time[userChoiceXY[0]] = 0;
				}
			}
		}
	}
	screenRefresh();
}

void screenRefresh(){
	if(currentSceneNumber != sceneNumber){
		switch (sceneNumber){
		case 2:
			memset(red, 0 , sizeof(red));
			sprintf(red, "%.3d", color[0]);

			memset(green, 0 , sizeof(green));
			sprintf(green, "%.3d", color[1]);

			memset(blue, 0 , sizeof(blue));
			sprintf(blue, "%.3d", color[2]);

			ucg_DrawString(&ucg, 25, 15,0,  "     Red   ");
			ucg_DrawString(&ucg, 25, 55,0,  "   Green   ");
			ucg_DrawString(&ucg, 25, 95,0,  "    Blue   ");
			break;
		case 5:
			memset(hour, 0 , sizeof(hour));
			sprintf(hour, "%.2d", time[0]);
			ucg_DrawString(&ucg, 35, 30,0,  "    HOUR    ");
			ucg_DrawString(&ucg, 55, 50,0,  (char*)hour);

			memset(minute, 0 , sizeof(minute));
			sprintf(minute, "%.2d", time[1]);
			ucg_DrawString(&ucg, 35, 80,0,  "   MINUTE   ");
			ucg_DrawString(&ucg, 55, 100,0,  (char*)minute);
			break;
		default:
			break;
		}
		currentSceneNumber = sceneNumber;
	}
	if(lastChoice != currentChoice){
		if(sceneNumber == 1){
			if ((currentChoice == Screen1_Setting)||(currentChoice == Screen1_Off)){
				ucg_DrawString(&ucg, 35, 50,0,  "                   ");
				ucg_DrawString(&ucg, 35, 70,0,  "                   ");
			}if((lastChoice == Screen1_Setting)||(lastChoice == Screen1_Off)){
				ucg_DrawString(&ucg, 35, 60,0,  "                   ");
			}
		}else if(sceneNumber == 2){
			if(currentChoice == Screen2_Red){
				ucg_DrawString(&ucg, 30, 35,0,  "   <        >   ");
				ucg_DrawString(&ucg, 30, 75,0,  "                ");
				ucg_DrawString(&ucg, 30, 115,0, "                ");
			}else if(currentChoice == Screen2_Green){
				ucg_DrawString(&ucg, 30, 35,0,  "                ");
				ucg_DrawString(&ucg, 30, 75,0,  "   <        >   ");
				ucg_DrawString(&ucg, 30, 115,0, "                ");
			}else if(currentChoice == Screen2_Blue){
				ucg_DrawString(&ucg, 30, 35,0,  "                ");
				ucg_DrawString(&ucg, 30, 75,0,  "                ");
				ucg_DrawString(&ucg, 30, 115,0, "   <        >   ");
			}
			ucg_DrawString(&ucg, 55, 35,0,  (char*)red);
			ucg_DrawString(&ucg, 55, 75,0,  (char*)green);
			ucg_DrawString(&ucg, 55, 115,0,  (char*)blue);
		}else if(sceneNumber == 5){
			if(currentChoice == Screen5_Hour){
				ucg_DrawString(&ucg, 30, 50,0,  "   <        >   ");
				ucg_DrawString(&ucg, 30, 100,0, "                ");
			}else if(currentChoice == Screen5_Minute){
				ucg_DrawString(&ucg, 30, 50,0,  "                ");
				ucg_DrawString(&ucg, 30, 100,0, "   <        >   ");
			}
			ucg_DrawString(&ucg, 60, 50,0,  (char*)hour);
			ucg_DrawString(&ucg, 60, 100,0,  (char*)minute);
		}
		lastChoice = currentChoice;
	}

	switch(currentChoice){
	case Screen0_None:
		sprintf(currentTime, "     %.2d : %.2d     ", time[0], time[1]);
		ucg_DrawString(&ucg, 30, 25,0,  "     Room     ");
		switch(room){
		case Living:
			ucg_DrawString(&ucg, 30, 50,0,  "    Living    ");
			break;
		case Study:
			ucg_DrawString(&ucg, 30, 50,0,  "    Study    ");
			break;
		case Sleep:
			ucg_DrawString(&ucg, 30, 50,0,  "    Sleep    ");
			break;
		case Dining:
			ucg_DrawString(&ucg, 30, 50,0,  "    Dining    ");
			break;
		case Exercise:
			ucg_DrawString(&ucg, 30, 50,0,  "    Exercise    ");
			break;
		}
		ucg_DrawString(&ucg, 30, 75,0,  "     Time     ");
		ucg_DrawString(&ucg, 30, 100,0,  currentTime);
		break;
	case Screen1_Manual:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Manual           ");
		ConfigUSARTBuffer(ActiveMode, Manual);
		break;
	case Screen1_Auto:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Auto             ");
		ConfigUSARTBuffer(ActiveMode, Rainbow);
		break;
	case Screen1_Storm:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Storm            ");
		ConfigUSARTBuffer(ActiveMode, Storm);
		break;
	case Screen1_Fire:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Fire             ");
		ConfigUSARTBuffer(ActiveMode, Fire);
		break;
	case Screen1_Aurora:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "   Aurora            ");
		ConfigUSARTBuffer(ActiveMode, Aurora);
		break;
	case Screen1_Party:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Party            ");
		ConfigUSARTBuffer(ActiveMode, Party);
		break;
	case Screen1_Warning:
		ucg_DrawString(&ucg, 35, 50,0,  "    Mode:            ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Warning          ");
		ConfigUSARTBuffer(ActiveMode, Warning);
		break;
	case Screen1_Setting:
		ucg_DrawString(&ucg, 35, 60,0,  "   Settings          ");
		break;
	case Screen1_Off:
		ucg_DrawString(&ucg, 35, 60,0,  "     Off          ");
		ConfigUSARTBuffer(Off, 0);
		break;
	case Screen2_Red:
		memset(red, 0 , sizeof(red));
		sprintf(red, "%.3d", color[0]);
		ucg_DrawString(&ucg, 25, 15,0,  "     Red   ");
		ucg_DrawString(&ucg, 55, 35,0,  (char*)red);
		ConfigUSARTBuffer(Red, color[0]);
		break;
	case Screen2_Green:
		memset(green, 0 , sizeof(green));
		sprintf(green, "%.3d", color[1]);
		ucg_DrawString(&ucg, 25, 55,0,  "   Green   ");
		ucg_DrawString(&ucg, 55, 75,0,  (char*)green);
		ConfigUSARTBuffer(Green, color[1]);
		break;
	case Screen2_Blue:
		memset(blue, 0 , sizeof(blue));
		sprintf(blue, "%.3d", color[2]);
		ucg_DrawString(&ucg, 25, 95,0,  "    Blue   ");
		ucg_DrawString(&ucg, 55, 115,0,  (char*)blue);
		ConfigUSARTBuffer(Blue, color[2]);
		break;
	case Screen3_Room:
		ucg_DrawString(&ucg, 35, 60,0,  "    Room         ");
		break;
	case Screen3_Time:
		ucg_DrawString(&ucg, 35, 60,0,  "    Time         ");
		break;
	case Screen4_Living:
		room = Living;
		ucg_DrawString(&ucg, 35, 50,0,  "    Room         ");
		ucg_DrawString(&ucg, 35, 70,0,  "   Living        ");
		ConfigUSARTBuffer(Room, Living);
		break;
	case Screen4_Sleep:
		room = Sleep;
		ucg_DrawString(&ucg, 35, 50,0,  "    Room         ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Sleep        ");
		ConfigUSARTBuffer(Room, Sleep);
		break;
	case Screen4_Study:
		room = Study;
		ucg_DrawString(&ucg, 35, 50,0,  "    Room         ");
		ucg_DrawString(&ucg, 35, 70,0,  "    Study        ");
		ConfigUSARTBuffer(Room, Study);
		break;
	case Screen4_Excercise:
		room = Exercise;
		ucg_DrawString(&ucg, 35, 50,0,  "    Room         ");
		ucg_DrawString(&ucg, 35, 70,0,  "  Exercise      ");
		ConfigUSARTBuffer(Room, Exercise);
		break;
	case Screen4_Dining:
		room = Dining;
		ucg_DrawString(&ucg, 35, 50,0,  "    Room         ");
		ucg_DrawString(&ucg, 35, 70,0,  "   Dining        ");
		ConfigUSARTBuffer(Room, Dining);
		break;
	case Screen5_Hour:
		memset(hour, 0 , sizeof(hour));
		sprintf(hour, "   %.2d   ", time[0]);
		ucg_DrawString(&ucg, 60, 50,0,  (char*)hour);
		ConfigUSARTBuffer(Hour, time[0]);
		break;
	case Screen5_Minute:
		memset(minute, 0 , sizeof(minute));
		sprintf(minute, "  %.2d  ", time[1]);
		ucg_DrawString(&ucg, 60, 100,0,  (char*)minute);
		ConfigUSARTBuffer(Minute, time[1]);
		break;
	case Screen6_End:
		ucg_DrawString(&ucg, 50, 50,0,  "      End      ");
		break;
	default:
		break;
	}
	TimerStop(SendDataTimer);
	SendDataTimer = NO_TIMER;
	SendDataTimer = TimerStart("SendData",500, TIMER_REPEAT_ONE_TIME, USART2_SendMessage, 0);
}

void ButtonInit(){
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	EXTI_InitTypeDef EXTI_InitStructure;

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_EXTIT, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

	GPIO_InitStructure.GPIO_Pin = BUTTON1_PIN;
	GPIO_Init(BUTTON1_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = BUTTON2_PIN;
	GPIO_Init(BUTTON2_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = BUTTON3_PIN;
	GPIO_Init(BUTTON3_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = BUTTON4_PIN;
	GPIO_Init(BUTTON4_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = BUTTON5_PIN;
	GPIO_Init(BUTTON5_PORT, &GPIO_InitStructure);

	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource4);

	EXTI_InitStructure.EXTI_Line = EXTI_Line4;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;

	EXTI_Init(&EXTI_InitStructure);

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
	NVIC_InitStructure.NVIC_IRQChannel = EXTI4_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_Init(&NVIC_InitStructure);
}

//Button B3
void EXTI4_IRQHandler(){
	static uint32_t lastTime = 0;
	EXTI_ClearITPendingBit(EXTI_Line4);
	if( GetMilSecTick() - lastTime > 200){
		ucg_ClearScreen(&ucg);
		lastTime = GetMilSecTick();
		TimerStop(changeSceneTimer);
		changeSceneTimer = TimerStart("Submit",500, TIMER_REPEAT_ONE_TIME, SubmitButtonHandler, &currentChoice);
	}
}


void LoadConfiguration(){
	ucg_ClearScreen(&ucg);
	sprintf(currentTime, "     %.2d : %.2d     ", time[0], time[1]);
	ucg_DrawString(&ucg, 30, 25,0,  "     Room     ");
	switch(room){
	case Living:
		ucg_DrawString(&ucg, 30, 50,0,  "    Living    ");
		break;
	case Study:
		ucg_DrawString(&ucg, 30, 50,0,  "    Study    ");
		break;
	case Sleep:
		ucg_DrawString(&ucg, 30, 50,0,  "    Sleep    ");
		break;
	case Dining:
		ucg_DrawString(&ucg, 30, 50,0,  "    Dining    ");
		break;
	case Exercise:
		ucg_DrawString(&ucg, 30, 50,0,  "    Exercise    ");
		break;
	}
	ucg_DrawString(&ucg, 30, 75,0,  "     Time     ");
	ucg_DrawString(&ucg, 30, 100,0,  currentTime);
}
void USART2_Init(){
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;
	RCC_AHB1PeriphClockCmd(USARTx_GPIO_CLK, ENABLE);
	RCC_APB2PeriphClockCmd(USARTx_CLK, ENABLE);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;

	GPIO_InitStructure.GPIO_Pin = USARTx_TX_PIN;
	GPIO_Init(USARTx_GPIO_PORT, &GPIO_InitStructure);
	GPIO_PinAFConfig(USARTx_GPIO_PORT, USARTx_TX_SOURCE, USARTx_AF);

//	GPIO_InitStructure.GPIO_Pin = USARTx_RX_PIN;
//	GPIO_Init(USARTx_GPIO_PORT, &GPIO_InitStructure);
//	GPIO_PinAFConfig(USARTx_GPIO_PORT, USARTx_RX_SOURCE, USARTx_AF);

	USART_InitStructure.USART_BaudRate = 9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx;// | USART_Mode_Rx;
	USART_Init(USART6, &USART_InitStructure);
	USART_Cmd(USART6, ENABLE);

	USART_ITConfig(USART2,USART_IT_RXNE , ENABLE);

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_Init(&NVIC_InitStructure);
}


void USART2_IRQHandler(){
	/*
	* Save the byte received concurrent with the transmission of the
	* last bit of the previous outgoing byte, and increment the buffer
	* position to the next byte.  Note that this read clears the
	* USART_IF_RXDATAV interrupt flag.
	*/
	if(!USART_GetITStatus(USART2, USART_IT_RXNE)){
		inbuf[bufpos++] = USART_ReceiveData(USART2);
	}
	//If corresponding start / stop byte
	USART_ClearITPendingBit(USART2,USART_IT_RXNE);
	UARTBufferPop((messageFrame_t*)inbuf);
}

void USART2_ResetBuffer(void){
	bufpos = 0;
	memset(inbuf,0,20);
}

void UARTBufferPop(messageFrame_t* inBufBase){
	messageFrame_t* common;
	common = inBufBase;
	uint8_t receivedData;
	receivedData = common->Data;
	if (((common->startByte == 0xB1)) && (common->stopByte == 0xFF)){
		if(common->msgID == Hour){
			time[0] = receivedData;
		}if(common->msgID == Minute){
			time[1] = receivedData;
		}
		USART2_ResetBuffer();
	}
}

void USART2_SendMessage(){
	while(!USART_GetFlagStatus(USART6, USART_FLAG_TXE));
	USART_SendData(USART6, messageFrame.startByte);

	while(!USART_GetFlagStatus(USART6, USART_FLAG_TXE));
	USART_SendData(USART6, messageFrame.msgID);

	while(!USART_GetFlagStatus(USART6, USART_FLAG_TXE));
	USART_SendData(USART6, messageFrame.Data);

	while(!USART_GetFlagStatus(USART6, USART_FLAG_TXE));
	USART_SendData(USART6, messageFrame.stopByte);
}

void ConfigUSARTBuffer(MessageType_t msgID, uint8_t data){
	messageFrame.msgID = msgID;
	messageFrame.Data = data;
}

